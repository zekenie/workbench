/* eslint-disable */
/* tslint:disable */
/*
 * ---------------------------------------------------------------
 * ## THIS FILE WAS GENERATED VIA SWAGGER-TYPESCRIPT-API        ##
 * ##                                                           ##
 * ## AUTHOR: acacode                                           ##
 * ## SOURCE: https://github.com/acacode/swagger-typescript-api ##
 * ---------------------------------------------------------------
 */

export interface App {
  id?: string;
  name?: string;
  organization?: Organization;
  status?: string;
}

export interface CheckStatus {
  name?: string;
  output?: string;
  status?: string;
  updated_at?: string;
}

export interface CreateAppRequest {
  app_name?: string;
  enable_subdomains?: boolean;
  network?: string;
  org_slug?: string;
}

export interface CreateLeaseRequest {
  description?: string;
  /** seconds lease will be valid */
  ttl?: number;
}

export interface CreateMachineRequest {
  /** An object defining the Machine configuration */
  config?: FlyMachineConfig;
  lease_ttl?: number;
  lsvd?: boolean;
  /** Unique name for this Machine. If omitted, one is generated for you */
  name?: string;
  /** The target region. Omitting this param launches in the same region as your WireGuard peer connection (somewhere near you). */
  region?: string;
  skip_launch?: boolean;
  skip_service_registration?: boolean;
}

/** Optional parameters */
export interface CreateOIDCTokenRequest {
  /** @example "https://fly.io/org-slug" */
  aud?: string;
}

export interface CreateSecretRequest {
  value?: number[];
}

export interface CreateVolumeRequest {
  compute?: FlyMachineGuest;
  compute_image?: string;
  encrypted?: boolean;
  fstype?: string;
  name?: string;
  region?: string;
  require_unique_zone?: boolean;
  size_gb?: number;
  /** restore from snapshot */
  snapshot_id?: string;
  snapshot_retention?: number;
  /** fork from remote volume */
  source_volume_id?: string;
}

export interface ErrorResponse {
  /** Deprecated */
  details?: any;
  error?: string;
  status?: MainStatusCode;
}

export interface ExtendVolumeRequest {
  size_gb?: number;
}

export interface ExtendVolumeResponse {
  needs_restart?: boolean;
  volume?: Volume;
}

export interface ImageRef {
  digest?: string;
  labels?: Record<string, string>;
  registry?: string;
  repository?: string;
  tag?: string;
}

export interface Lease {
  /** Description or reason for the Lease. */
  description?: string;
  /** ExpiresAt is the unix timestamp in UTC to denote when the Lease will no longer be valid. */
  expires_at?: number;
  /** Nonce is the unique ID autogenerated and associated with the Lease. */
  nonce?: string;
  /** Owner is the user identifier which acquired the Lease. */
  owner?: string;
  /** Machine version */
  version?: string;
}

export interface ListApp {
  id?: string;
  machine_count?: number;
  name?: string;
  network?: any;
}

export interface ListAppsResponse {
  apps?: ListApp[];
  total_apps?: number;
}

export interface ListSecret {
  label?: string;
  publickey?: number[];
  type?: string;
}

export interface ListenSocket {
  address?: string;
  proto?: string;
}

export interface Machine {
  checks?: CheckStatus[];
  config?: FlyMachineConfig;
  created_at?: string;
  events?: MachineEvent[];
  host_status?: "ok" | "unknown" | "unreachable";
  id?: string;
  image_ref?: ImageRef;
  incomplete_config?: FlyMachineConfig;
  /** InstanceID is unique for each version of the machine */
  instance_id?: string;
  name?: string;
  /** Nonce is only every returned on machine creation if a lease_duration was provided. */
  nonce?: string;
  /** PrivateIP is the internal 6PN address of the machine. */
  private_ip?: string;
  region?: string;
  state?: string;
  updated_at?: string;
}

export interface MachineEvent {
  id?: string;
  request?: any;
  source?: string;
  status?: string;
  timestamp?: number;
  type?: string;
}

export interface MachineExecRequest {
  /** Deprecated: use Command instead */
  cmd?: string;
  command?: string[];
  timeout?: number;
}

export interface MachineVersion {
  user_config?: FlyMachineConfig;
  version?: string;
}

export interface Organization {
  name?: string;
  slug?: string;
}

export interface ProcessStat {
  command?: string;
  cpu?: number;
  directory?: string;
  listen_sockets?: ListenSocket[];
  pid?: number;
  rss?: number;
  rtime?: number;
  stime?: number;
}

export interface SignalRequest {
  signal?:
    | "SIGABRT"
    | "SIGALRM"
    | "SIGFPE"
    | "SIGHUP"
    | "SIGILL"
    | "SIGINT"
    | "SIGKILL"
    | "SIGPIPE"
    | "SIGQUIT"
    | "SIGSEGV"
    | "SIGTERM"
    | "SIGTRAP"
    | "SIGUSR1";
}

export interface StopRequest {
  signal?: string;
  timeout?: FlyDuration;
}

export interface UpdateMachineRequest {
  /** An object defining the Machine configuration */
  config?: FlyMachineConfig;
  current_version?: string;
  lease_ttl?: number;
  lsvd?: boolean;
  /** Unique name for this Machine. If omitted, one is generated for you */
  name?: string;
  /** The target region. Omitting this param launches in the same region as your WireGuard peer connection (somewhere near you). */
  region?: string;
  skip_launch?: boolean;
  skip_service_registration?: boolean;
}

export interface UpdateVolumeRequest {
  auto_backup_enabled?: boolean;
  snapshot_retention?: number;
}

export interface Volume {
  attached_alloc_id?: string;
  attached_machine_id?: string;
  auto_backup_enabled?: boolean;
  block_size?: number;
  blocks?: number;
  blocks_avail?: number;
  blocks_free?: number;
  created_at?: string;
  encrypted?: boolean;
  fstype?: string;
  host_status?: "ok" | "unknown" | "unreachable";
  id?: string;
  name?: string;
  region?: string;
  size_gb?: number;
  snapshot_retention?: number;
  state?: string;
  zone?: string;
}

export interface VolumeSnapshot {
  created_at?: string;
  digest?: string;
  id?: string;
  retention_days?: number;
  size?: number;
  status?: string;
}

export interface FlyContainerConfig {
  /** CmdOverride is used to override the default command of the image. */
  cmd?: string[];
  /**
   * DependsOn can be used to define dependencies between containers. The container will only be
   * started after all of its dependent conditions have been satisfied.
   */
  depends_on?: FlyContainerDependency[];
  /** EntrypointOverride is used to override the default entrypoint of the image. */
  entrypoint?: string[];
  /** ExtraEnv is used to add additional environment variables to the container. */
  env?: Record<string, string>;
  /** EnvFrom can be provided to set environment variables from machine fields. */
  env_from?: FlyEnvFrom[];
  /**
   * Image Config overrides - these fields are used to override the image configuration.
   * If not provided, the image configuration will be used.
   * ExecOverride is used to override the default command of the image.
   */
  exec?: string[];
  /** Files are files that will be written to the container file system. */
  files?: FlyFile[];
  /** Image is the docker image to run. */
  image?: string;
  /** Name is used to identify the container in the machine. */
  name?: string;
  /**
   * Restart is used to define the restart policy for the container. NOTE: spot-price is not
   * supported for containers.
   */
  restart?: FlyMachineRestart;
  /**
   * Secrets can be provided at the process level to explicitly indicate which secrets should be
   * used for the process. If not provided, the secrets provided at the machine level will be used.
   */
  secrets?: FlyMachineSecret[];
  /** Stop is used to define the signal and timeout for stopping the container. */
  stop?: FlyStopConfig;
  /** UserOverride is used to override the default user of the image. */
  user?: string;
}

export interface FlyContainerDependency {
  condition?: "exited_successfully" | "healthy" | "started";
  name?: string;
}

export enum FlyContainerDependencyCondition {
  ExitedSuccessfully = "exited_successfully",
  Healthy = "healthy",
  Started = "started",
}

export interface FlyDNSConfig {
  dns_forward_rules?: FlyDnsForwardRule[];
  hostname?: string;
  hostname_fqdn?: string;
  nameservers?: string[];
  options?: FlyDnsOption[];
  searches?: string[];
  skip_registration?: boolean;
}

export interface FlyDuration {
  "time.Duration"?:
    | -9223372036854776000
    | 9223372036854776000
    | 1
    | 1000
    | 1000000
    | 1000000000
    | 60000000000
    | 3600000000000;
}

/** EnvVar defines an environment variable to be populated from a machine field, env_var */
export interface FlyEnvFrom {
  /**
   * EnvVar is required and is the name of the environment variable that will be set from the
   * secret. It must be a valid environment variable name.
   */
  env_var?: string;
  /** FieldRef selects a field of the Machine: supports id, version, app_name, private_ip, region, image. */
  field_ref?: "id" | "version" | "app_name" | "private_ip" | "region" | "image";
}

/** A file that will be written to the Machine. One of RawValue or SecretName must be set. */
export interface FlyFile {
  /**
   * GuestPath is the path on the machine where the file will be written and must be an absolute path.
   * For example: /full/path/to/file.json
   */
  guest_path?: string;
  /** Mode bits used to set permissions on this file as accepted by chmod(2). */
  mode?: number;
  /** The base64 encoded string of the file contents. */
  raw_value?: string;
  /** The name of the secret that contains the base64 encoded file contents. */
  secret_name?: string;
}

export interface FlyHTTPOptions {
  compress?: boolean;
  h2_backend?: boolean;
  headers_read_timeout?: number;
  idle_timeout?: number;
  response?: FlyHTTPResponseOptions;
}

export interface FlyHTTPResponseOptions {
  headers?: Record<string, any>;
  pristine?: boolean;
}

/** An optional object that defines one or more named checks. The key for each check is the check name. */
export interface FlyMachineCheck {
  /** The time to wait after a VM starts before checking its health */
  grace_period?: FlyDuration;
  headers?: FlyMachineHTTPHeader[];
  /** The time between connectivity checks */
  interval?: FlyDuration;
  /** Kind of the check (informational, readiness) */
  kind?: "informational" | "readiness";
  /** For http checks, the HTTP method to use to when making the request */
  method?: string;
  /** For http checks, the path to send the request to */
  path?: string;
  /** The port to connect to, often the same as internal_port */
  port?: number;
  /** For http checks, whether to use http or https */
  protocol?: string;
  /** The maximum time a connection can take before being reported as failing its health check */
  timeout?: FlyDuration;
  /** If the protocol is https, the hostname to use for TLS certificate validation */
  tls_server_name?: string;
  /** For http checks with https protocol, whether or not to verify the TLS certificate */
  tls_skip_verify?: boolean;
  /** tcp or http */
  type?: string;
}

export interface FlyMachineConfig {
  /** Optional boolean telling the Machine to destroy itself once it’s complete (default false) */
  auto_destroy?: boolean;
  checks?: Record<string, FlyMachineCheck>;
  /**
   * Containers are a list of containers that will run in the machine. Currently restricted to
   * only specific organizations.
   */
  containers?: FlyContainerConfig[];
  /** Deprecated: use Service.Autostart instead */
  disable_machine_autostart?: boolean;
  dns?: FlyDNSConfig;
  /** An object filled with key/value pairs to be set as environment variables */
  env?: Record<string, string>;
  files?: FlyFile[];
  guest?: FlyMachineGuest;
  /** The docker image to run */
  image?: string;
  init?: FlyMachineInit;
  metadata?: Record<string, string>;
  metrics?: FlyMachineMetrics;
  mounts?: FlyMachineMount[];
  processes?: FlyMachineProcess[];
  /** The Machine restart policy defines whether and how flyd restarts a Machine after its main process exits. See https://fly.io/docs/machines/guides-examples/machine-restart-policy/. */
  restart?: FlyMachineRestart;
  schedule?: string;
  services?: FlyMachineService[];
  /** Deprecated: use Guest instead */
  size?: string;
  /**
   * Standbys enable a machine to be a standby for another. In the event of a hardware failure,
   * the standby machine will be started.
   */
  standbys?: string[];
  statics?: FlyStatic[];
  stop_config?: FlyStopConfig;
}

export interface FlyMachineGuest {
  cpu_kind?: string;
  cpus?: number;
  gpu_kind?: string;
  gpus?: number;
  host_dedication_id?: string;
  kernel_args?: string[];
  memory_mb?: number;
}

/** For http checks, an array of objects with string field Name and array of strings field Values. The key/value pairs specify header and header values that will get passed with the check call. */
export interface FlyMachineHTTPHeader {
  /** The header name */
  name?: string;
  /** The header value */
  values?: string[];
}

export interface FlyMachineInit {
  cmd?: string[];
  entrypoint?: string[];
  exec?: string[];
  kernel_args?: string[];
  swap_size_mb?: number;
  tty?: boolean;
}

export interface FlyMachineMetrics {
  https?: boolean;
  path?: string;
  port?: number;
}

export interface FlyMachineMount {
  add_size_gb?: number;
  encrypted?: boolean;
  extend_threshold_percent?: number;
  name?: string;
  path?: string;
  size_gb?: number;
  size_gb_limit?: number;
  volume?: string;
}

export interface FlyMachinePort {
  end_port?: number;
  force_https?: boolean;
  handlers?: string[];
  http_options?: FlyHTTPOptions;
  port?: number;
  proxy_proto_options?: FlyProxyProtoOptions;
  start_port?: number;
  tls_options?: FlyTLSOptions;
}

export interface FlyMachineProcess {
  cmd?: string[];
  entrypoint?: string[];
  env?: Record<string, string>;
  /** EnvFrom can be provided to set environment variables from machine fields. */
  env_from?: FlyEnvFrom[];
  exec?: string[];
  /**
   * IgnoreAppSecrets can be set to true to ignore the secrets for the App the Machine belongs to
   * and only use the secrets provided at the process level. The default/legacy behavior is to use
   * the secrets provided at the App level.
   */
  ignore_app_secrets?: boolean;
  /**
   * Secrets can be provided at the process level to explicitly indicate which secrets should be
   * used for the process. If not provided, the secrets provided at the machine level will be used.
   */
  secrets?: FlyMachineSecret[];
  user?: string;
}

/** The Machine restart policy defines whether and how flyd restarts a Machine after its main process exits. See https://fly.io/docs/machines/guides-examples/machine-restart-policy/. */
export interface FlyMachineRestart {
  /** GPU bid price for spot Machines. */
  gpu_bid_price?: number;
  /** When policy is on-failure, the maximum number of times to attempt to restart the Machine before letting it stop. */
  max_retries?: number;
  /**
   * * no - Never try to restart a Machine automatically when its main process exits, whether that’s on purpose or on a crash.
   * * always - Always restart a Machine automatically and never let it enter a stopped state, even when the main process exits cleanly.
   * * on-failure - Try up to MaxRetries times to automatically restart the Machine if it exits with a non-zero exit code. Default when no explicit policy is set, and for Machines with schedules.
   * * spot-price - Starts the Machine only when there is capacity and the spot price is less than or equal to the bid price.
   */
  policy?: "no" | "always" | "on-failure" | "spot-price";
}

/** A Secret needing to be set in the environment of the Machine. env_var is required */
export interface FlyMachineSecret {
  /**
   * EnvVar is required and is the name of the environment variable that will be set from the
   * secret. It must be a valid environment variable name.
   */
  env_var?: string;
  /**
   * Name is optional and when provided is used to reference a secret name where the EnvVar is
   * different from what was set as the secret name.
   */
  name?: string;
}

export interface FlyMachineService {
  autostart?: boolean;
  /**
   * Accepts a string (new format) or a boolean (old format). For backward compatibility with older clients, the API continues to use booleans for "off" and "stop" in responses.
   * * "off" or false - Do not autostop the Machine.
   * * "stop" or true - Automatically stop the Machine.
   * * "suspend" - Automatically suspend the Machine, falling back to a full stop if this is not possible.
   */
  autostop?: "off" | "stop" | "suspend";
  checks?: FlyMachineCheck[];
  concurrency?: FlyMachineServiceConcurrency;
  force_instance_description?: string;
  force_instance_key?: string;
  internal_port?: number;
  min_machines_running?: number;
  ports?: FlyMachinePort[];
  protocol?: string;
}

export interface FlyMachineServiceConcurrency {
  hard_limit?: number;
  soft_limit?: number;
  type?: string;
}

export interface FlyProxyProtoOptions {
  version?: string;
}

export interface FlyStatic {
  guest_path: string;
  index_document?: string;
  tigris_bucket?: string;
  url_prefix: string;
}

export interface FlyStopConfig {
  signal?: string;
  timeout?: FlyDuration;
}

export interface FlyTLSOptions {
  alpn?: string[];
  default_self_signed?: boolean;
  versions?: string[];
}

export interface FlyDnsForwardRule {
  addr?: string;
  basename?: string;
}

export interface FlyDnsOption {
  name?: string;
  value?: string;
}

export interface Flydv1ExecResponse {
  exit_code?: number;
  exit_signal?: number;
  stderr?: string;
  stdout?: string;
}

export enum MainStatusCode {
  Unknown = "unknown",
  CapacityErr = "insufficient_capacity",
}

export type QueryParamsType = Record<string | number, any>;
export type ResponseFormat = keyof Omit<Body, "body" | "bodyUsed">;

export interface FullRequestParams extends Omit<RequestInit, "body"> {
  /** set parameter to `true` for call `securityWorker` for this request */
  secure?: boolean;
  /** request path */
  path: string;
  /** content type of request body */
  type?: ContentType;
  /** query params */
  query?: QueryParamsType;
  /** format of response (i.e. response.json() -> format: "json") */
  format?: ResponseFormat;
  /** request body */
  body?: unknown;
  /** base url */
  baseUrl?: string;
  /** request cancellation token */
  cancelToken?: CancelToken;
}

export type RequestParams = Omit<
  FullRequestParams,
  "body" | "method" | "query" | "path"
>;

export interface ApiConfig<SecurityDataType = unknown> {
  baseUrl?: string;
  baseApiParams?: Omit<RequestParams, "baseUrl" | "cancelToken" | "signal">;
  securityWorker?: (
    securityData: SecurityDataType | null
  ) => Promise<RequestParams | void> | RequestParams | void;
  customFetch?: typeof fetch;
}

export interface HttpResponse<D extends unknown, E extends unknown = unknown>
  extends Response {
  data: D;
  error: E;
}

type CancelToken = Symbol | string | number;

export enum ContentType {
  Json = "application/json",
  FormData = "multipart/form-data",
  UrlEncoded = "application/x-www-form-urlencoded",
  Text = "text/plain",
}

export class HttpClient<SecurityDataType = unknown> {
  public baseUrl: string = "https://api.machines.dev/v1";
  private securityData: SecurityDataType | null = null;
  private securityWorker?: ApiConfig<SecurityDataType>["securityWorker"];
  private abortControllers = new Map<CancelToken, AbortController>();
  private customFetch = (...fetchParams: Parameters<typeof fetch>) =>
    fetch(...fetchParams);

  private baseApiParams: RequestParams = {
    credentials: "same-origin",
    headers: {},
    redirect: "follow",
    referrerPolicy: "no-referrer",
  };

  constructor(apiConfig: ApiConfig<SecurityDataType> = {}) {
    Object.assign(this, apiConfig);
  }

  public setSecurityData = (data: SecurityDataType | null) => {
    this.securityData = data;
  };

  protected encodeQueryParam(key: string, value: any) {
    const encodedKey = encodeURIComponent(key);
    return `${encodedKey}=${encodeURIComponent(typeof value === "number" ? value : `${value}`)}`;
  }

  protected addQueryParam(query: QueryParamsType, key: string) {
    return this.encodeQueryParam(key, query[key]);
  }

  protected addArrayQueryParam(query: QueryParamsType, key: string) {
    const value = query[key];
    return value.map((v: any) => this.encodeQueryParam(key, v)).join("&");
  }

  protected toQueryString(rawQuery?: QueryParamsType): string {
    const query = rawQuery || {};
    const keys = Object.keys(query).filter(
      (key) => "undefined" !== typeof query[key]
    );
    return keys
      .map((key) =>
        Array.isArray(query[key])
          ? this.addArrayQueryParam(query, key)
          : this.addQueryParam(query, key)
      )
      .join("&");
  }

  protected addQueryParams(rawQuery?: QueryParamsType): string {
    const queryString = this.toQueryString(rawQuery);
    return queryString ? `?${queryString}` : "";
  }

  private contentFormatters: Record<ContentType, (input: any) => any> = {
    [ContentType.Json]: (input: any) =>
      input !== null && (typeof input === "object" || typeof input === "string")
        ? JSON.stringify(input)
        : input,
    [ContentType.Text]: (input: any) =>
      input !== null && typeof input !== "string"
        ? JSON.stringify(input)
        : input,
    [ContentType.FormData]: (input: any) =>
      Object.keys(input || {}).reduce((formData, key) => {
        const property = input[key];
        formData.append(
          key,
          property instanceof Blob
            ? property
            : typeof property === "object" && property !== null
              ? JSON.stringify(property)
              : `${property}`
        );
        return formData;
      }, new FormData()),
    [ContentType.UrlEncoded]: (input: any) => this.toQueryString(input),
  };

  protected mergeRequestParams(
    params1: RequestParams,
    params2?: RequestParams
  ): RequestParams {
    return {
      ...this.baseApiParams,
      ...params1,
      ...(params2 || {}),
      headers: {
        ...(this.baseApiParams.headers || {}),
        ...(params1.headers || {}),
        ...((params2 && params2.headers) || {}),
      },
    };
  }

  protected createAbortSignal = (
    cancelToken: CancelToken
  ): AbortSignal | undefined => {
    if (this.abortControllers.has(cancelToken)) {
      const abortController = this.abortControllers.get(cancelToken);
      if (abortController) {
        return abortController.signal;
      }
      return void 0;
    }

    const abortController = new AbortController();
    this.abortControllers.set(cancelToken, abortController);
    return abortController.signal;
  };

  public abortRequest = (cancelToken: CancelToken) => {
    const abortController = this.abortControllers.get(cancelToken);

    if (abortController) {
      abortController.abort();
      this.abortControllers.delete(cancelToken);
    }
  };

  public request = async <T = any, E = any>({
    body,
    secure,
    path,
    type,
    query,
    format,
    baseUrl,
    cancelToken,
    ...params
  }: FullRequestParams): Promise<HttpResponse<T, E>> => {
    const secureParams =
      ((typeof secure === "boolean" ? secure : this.baseApiParams.secure) &&
        this.securityWorker &&
        (await this.securityWorker(this.securityData))) ||
      {};
    const requestParams = this.mergeRequestParams(params, secureParams);
    const queryString = query && this.toQueryString(query);
    const payloadFormatter = this.contentFormatters[type || ContentType.Json];
    const responseFormat = format || requestParams.format;

    return this.customFetch(
      `${baseUrl || this.baseUrl || ""}${path}${queryString ? `?${queryString}` : ""}`,
      {
        ...requestParams,
        headers: {
          ...(requestParams.headers || {}),
          ...(type && type !== ContentType.FormData
            ? { "Content-Type": type }
            : {}),
        },
        signal:
          (cancelToken
            ? this.createAbortSignal(cancelToken)
            : requestParams.signal) || null,
        body:
          typeof body === "undefined" || body === null
            ? null
            : payloadFormatter(body),
      }
    ).then(async (response) => {
      const r = response.clone() as HttpResponse<T, E>;
      r.data = null as unknown as T;
      r.error = null as unknown as E;

      const data = !responseFormat
        ? r
        : await response[responseFormat]()
            .then((data) => {
              if (r.ok) {
                r.data = data;
              } else {
                r.error = data;
              }
              return r;
            })
            .catch((e) => {
              r.error = e;
              return r;
            });

      if (cancelToken) {
        this.abortControllers.delete(cancelToken);
      }

      if (!response.ok) throw data;
      return data;
    });
  };
}

/**
 * @title Machines API
 * @version 1.0
 * @license Apache 2.0 (http://www.apache.org/licenses/LICENSE-2.0.html)
 * @baseUrl https://api.machines.dev/v1
 * @externalDocs https://fly.io/docs/machines/working-with-machines/
 * @contact
 *
 * This site hosts documentation generated from the Fly.io Machines API OpenAPI specification. Visit our complete [Machines API docs](https://fly.io/docs/machines/api/) for how to get started, more information about each endpoint, parameter descriptions, and examples.
 */
export class Api<
  SecurityDataType extends unknown,
> extends HttpClient<SecurityDataType> {
  apps = {
    /**
     * @description List all apps with the ability to filter by organization slug.
     *
     * @tags Apps
     * @name AppsList
     * @summary List Apps
     * @request GET:/apps
     */
    appsList: (
      query: {
        /** The org slug, or 'personal', to filter apps */
        org_slug: string;
      },
      params: RequestParams = {}
    ) =>
      this.request<ListAppsResponse, any>({
        path: `/apps`,
        method: "GET",
        query: query,
        format: "json",
        ...params,
      }),

    /**
     * @description Create an app with the specified details in the request body.
     *
     * @tags Apps
     * @name AppsCreate
     * @summary Create App
     * @request POST:/apps
     */
    appsCreate: (request: CreateAppRequest, params: RequestParams = {}) =>
      this.request<void, ErrorResponse>({
        path: `/apps`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Retrieve details about a specific app by its name.
     *
     * @tags Apps
     * @name AppsShow
     * @summary Get App
     * @request GET:/apps/{app_name}
     */
    appsShow: (appName: string, params: RequestParams = {}) =>
      this.request<App, any>({
        path: `/apps/${appName}`,
        method: "GET",
        format: "json",
        ...params,
      }),

    /**
     * @description Delete an app by its name.
     *
     * @tags Apps
     * @name AppsDelete
     * @summary Destroy App
     * @request DELETE:/apps/{app_name}
     */
    appsDelete: (appName: string, params: RequestParams = {}) =>
      this.request<void, any>({
        path: `/apps/${appName}`,
        method: "DELETE",
        ...params,
      }),

    /**
     * @description List all Machines associated with a specific app, with optional filters for including deleted Machines and filtering by region.
     *
     * @tags Machines
     * @name MachinesList
     * @summary List Machines
     * @request GET:/apps/{app_name}/machines
     */
    machinesList: (
      appName: string,
      query?: {
        /** Include deleted machines */
        include_deleted?: boolean;
        /** Region filter */
        region?: string;
        /** comma separated list of states to filter (created, started, stopped, suspended) */
        state?: string;
        /** Only return summary info about machines (omit config, checks, events, host_status, nonce, etc.) */
        summary?: boolean;
      },
      params: RequestParams = {}
    ) =>
      this.request<Machine[], any>({
        path: `/apps/${appName}/machines`,
        method: "GET",
        query: query,
        format: "json",
        ...params,
      }),

    /**
     * @description Create a Machine within a specific app using the details provided in the request body. **Important**: This request can fail, and you’re responsible for handling that failure. If you ask for a large Machine, or a Machine in a region we happen to be at capacity for, you might need to retry the request, or to fall back to another region. If you’re working directly with the Machines API, you’re taking some responsibility for your own orchestration!
     *
     * @tags Machines
     * @name MachinesCreate
     * @summary Create Machine
     * @request POST:/apps/{app_name}/machines
     */
    machinesCreate: (
      appName: string,
      request: CreateMachineRequest,
      params: RequestParams = {}
    ) =>
      this.request<Machine, any>({
        path: `/apps/${appName}/machines`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Get details of a specific Machine within an app by the Machine ID.
     *
     * @tags Machines
     * @name MachinesShow
     * @summary Get Machine
     * @request GET:/apps/{app_name}/machines/{machine_id}
     */
    machinesShow: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<Machine, any>({
        path: `/apps/${appName}/machines/${machineId}`,
        method: "GET",
        format: "json",
        ...params,
      }),

    /**
     * @description Update a Machine's configuration using the details provided in the request body.
     *
     * @tags Machines
     * @name MachinesUpdate
     * @summary Update Machine
     * @request POST:/apps/{app_name}/machines/{machine_id}
     */
    machinesUpdate: (
      appName: string,
      machineId: string,
      request: UpdateMachineRequest,
      params: RequestParams = {}
    ) =>
      this.request<Machine, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Delete a specific Machine within an app by Machine ID, with an optional force parameter to force kill the Machine if it's running.
     *
     * @tags Machines
     * @name MachinesDelete
     * @summary Destroy Machine
     * @request DELETE:/apps/{app_name}/machines/{machine_id}
     */
    machinesDelete: (
      appName: string,
      machineId: string,
      query?: {
        /** Force kill the machine if it's running */
        force?: boolean;
      },
      params: RequestParams = {}
    ) =>
      this.request<void, any>({
        path: `/apps/${appName}/machines/${machineId}`,
        method: "DELETE",
        query: query,
        ...params,
      }),

    /**
     * @description “Cordoning” a Machine refers to disabling its services, so the Fly Proxy won’t route requests to it. In flyctl this is used by blue/green deployments; one set of Machines is started up with services disabled, and when they are all healthy, the services are enabled on the new Machines and disabled on the old ones.
     *
     * @tags Machines
     * @name MachinesCordon
     * @summary Cordon Machine
     * @request POST:/apps/{app_name}/machines/{machine_id}/cordon
     */
    machinesCordon: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<void, any>({
        path: `/apps/${appName}/machines/${machineId}/cordon`,
        method: "POST",
        ...params,
      }),

    /**
     * @description List all events associated with a specific Machine within an app.
     *
     * @tags Machines
     * @name MachinesListEvents
     * @summary List Events
     * @request GET:/apps/{app_name}/machines/{machine_id}/events
     */
    machinesListEvents: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<MachineEvent[], any>({
        path: `/apps/${appName}/machines/${machineId}/events`,
        method: "GET",
        format: "json",
        ...params,
      }),

    /**
     * @description Execute a command on a specific Machine and return the raw command output bytes.
     *
     * @tags Machines
     * @name MachinesExec
     * @summary Execute Command
     * @request POST:/apps/{app_name}/machines/{machine_id}/exec
     */
    machinesExec: (
      appName: string,
      machineId: string,
      request: MachineExecRequest,
      params: RequestParams = {}
    ) =>
      this.request<Flydv1ExecResponse, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}/exec`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Retrieve the current lease of a specific Machine within an app. Machine leases can be used to obtain an exclusive lock on modifying a Machine.
     *
     * @tags Machines
     * @name MachinesShowLease
     * @summary Get Lease
     * @request GET:/apps/{app_name}/machines/{machine_id}/lease
     */
    machinesShowLease: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<Lease, any>({
        path: `/apps/${appName}/machines/${machineId}/lease`,
        method: "GET",
        format: "json",
        ...params,
      }),

    /**
     * @description Create a lease for a specific Machine within an app using the details provided in the request body. Machine leases can be used to obtain an exclusive lock on modifying a Machine.
     *
     * @tags Machines
     * @name MachinesCreateLease
     * @summary Create Lease
     * @request POST:/apps/{app_name}/machines/{machine_id}/lease
     */
    machinesCreateLease: (
      appName: string,
      machineId: string,
      request: CreateLeaseRequest,
      params: RequestParams = {}
    ) =>
      this.request<Lease, any>({
        path: `/apps/${appName}/machines/${machineId}/lease`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Release the lease of a specific Machine within an app. Machine leases can be used to obtain an exclusive lock on modifying a Machine.
     *
     * @tags Machines
     * @name MachinesReleaseLease
     * @summary Release Lease
     * @request DELETE:/apps/{app_name}/machines/{machine_id}/lease
     */
    machinesReleaseLease: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<void, any>({
        path: `/apps/${appName}/machines/${machineId}/lease`,
        method: "DELETE",
        ...params,
      }),

    /**
     * @description Retrieve metadata for a specific Machine within an app.
     *
     * @tags Machines
     * @name MachinesShowMetadata
     * @summary Get Metadata
     * @request GET:/apps/{app_name}/machines/{machine_id}/metadata
     */
    machinesShowMetadata: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<Record<string, string>, any>({
        path: `/apps/${appName}/machines/${machineId}/metadata`,
        method: "GET",
        format: "json",
        ...params,
      }),

    /**
     * @description Update metadata for a specific machine within an app by providing a metadata key.
     *
     * @tags Machines
     * @name MachinesUpdateMetadata
     * @summary Update Metadata
     * @request POST:/apps/{app_name}/machines/{machine_id}/metadata/{key}
     */
    machinesUpdateMetadata: (
      appName: string,
      machineId: string,
      key: string,
      params: RequestParams = {}
    ) =>
      this.request<void, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}/metadata/${key}`,
        method: "POST",
        ...params,
      }),

    /**
     * @description Delete metadata for a specific Machine within an app by providing a metadata key.
     *
     * @tags Machines
     * @name MachinesDeleteMetadata
     * @summary Delete Metadata
     * @request DELETE:/apps/{app_name}/machines/{machine_id}/metadata/{key}
     */
    machinesDeleteMetadata: (
      appName: string,
      machineId: string,
      key: string,
      params: RequestParams = {}
    ) =>
      this.request<void, any>({
        path: `/apps/${appName}/machines/${machineId}/metadata/${key}`,
        method: "DELETE",
        ...params,
      }),

    /**
     * @description List all processes running on a specific Machine within an app, with optional sorting parameters.
     *
     * @tags Machines
     * @name MachinesListProcesses
     * @summary List Processes
     * @request GET:/apps/{app_name}/machines/{machine_id}/ps
     */
    machinesListProcesses: (
      appName: string,
      machineId: string,
      query?: {
        /** Sort by */
        sort_by?: string;
        /** Order */
        order?: string;
      },
      params: RequestParams = {}
    ) =>
      this.request<ProcessStat[], ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}/ps`,
        method: "GET",
        query: query,
        format: "json",
        ...params,
      }),

    /**
     * @description Restart a specific Machine within an app, with an optional timeout parameter.
     *
     * @tags Machines
     * @name MachinesRestart
     * @summary Restart Machine
     * @request POST:/apps/{app_name}/machines/{machine_id}/restart
     */
    machinesRestart: (
      appName: string,
      machineId: string,
      query?: {
        /** Restart timeout as a Go duration string or number of seconds */
        timeout?: string;
        /** Unix signal name */
        signal?: string;
      },
      params: RequestParams = {}
    ) =>
      this.request<void, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}/restart`,
        method: "POST",
        query: query,
        ...params,
      }),

    /**
     * @description Send a signal to a specific Machine within an app using the details provided in the request body.
     *
     * @tags Machines
     * @name MachinesSignal
     * @summary Signal Machine
     * @request POST:/apps/{app_name}/machines/{machine_id}/signal
     */
    machinesSignal: (
      appName: string,
      machineId: string,
      request: SignalRequest,
      params: RequestParams = {}
    ) =>
      this.request<void, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}/signal`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Start a specific Machine within an app.
     *
     * @tags Machines
     * @name MachinesStart
     * @summary Start Machine
     * @request POST:/apps/{app_name}/machines/{machine_id}/start
     */
    machinesStart: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<void, any>({
        path: `/apps/${appName}/machines/${machineId}/start`,
        method: "POST",
        ...params,
      }),

    /**
     * @description Stop a specific Machine within an app, with an optional request body to specify signal and timeout.
     *
     * @tags Machines
     * @name MachinesStop
     * @summary Stop Machine
     * @request POST:/apps/{app_name}/machines/{machine_id}/stop
     */
    machinesStop: (
      appName: string,
      machineId: string,
      request: StopRequest,
      params: RequestParams = {}
    ) =>
      this.request<void, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}/stop`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * @description Suspend a specific Machine within an app. The next start operation will attempt (but is not guaranteed) to resume the Machine from a snapshot taken at suspension time, rather than performing a cold boot.
     *
     * @tags Machines
     * @name MachinesSuspend
     * @summary Suspend Machine
     * @request POST:/apps/{app_name}/machines/{machine_id}/suspend
     */
    machinesSuspend: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<void, any>({
        path: `/apps/${appName}/machines/${machineId}/suspend`,
        method: "POST",
        ...params,
      }),

    /**
     * @description “Cordoning” a Machine refers to disabling its services, so the Fly Proxy won’t route requests to it. In flyctl this is used by blue/green deployments; one set of Machines is started up with services disabled, and when they are all healthy, the services are enabled on the new Machines and disabled on the old ones.
     *
     * @tags Machines
     * @name MachinesUncordon
     * @summary Uncordon Machine
     * @request POST:/apps/{app_name}/machines/{machine_id}/uncordon
     */
    machinesUncordon: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<void, any>({
        path: `/apps/${appName}/machines/${machineId}/uncordon`,
        method: "POST",
        ...params,
      }),

    /**
     * @description List all versions of the configuration for a specific Machine within an app.
     *
     * @tags Machines
     * @name MachinesListVersions
     * @summary List Versions
     * @request GET:/apps/{app_name}/machines/{machine_id}/versions
     */
    machinesListVersions: (
      appName: string,
      machineId: string,
      params: RequestParams = {}
    ) =>
      this.request<MachineVersion[], any>({
        path: `/apps/${appName}/machines/${machineId}/versions`,
        method: "GET",
        format: "json",
        ...params,
      }),

    /**
     * @description Wait for a Machine to reach a specific state. Specify the desired state with the state parameter. See the [Machine states table](https://fly.io/docs/machines/working-with-machines/#machine-states) for a list of possible states. The default for this parameter is `started`. This request will block for up to 60 seconds. Set a shorter timeout with the timeout parameter.
     *
     * @tags Machines
     * @name MachinesWait
     * @summary Wait for State
     * @request GET:/apps/{app_name}/machines/{machine_id}/wait
     */
    machinesWait: (
      appName: string,
      machineId: string,
      query?: {
        /** 26-character Machine version ID */
        instance_id?: string;
        /** wait timeout. default 60s */
        timeout?: number;
        /** desired state */
        state?: "started" | "stopped" | "suspended" | "destroyed";
      },
      params: RequestParams = {}
    ) =>
      this.request<void, ErrorResponse>({
        path: `/apps/${appName}/machines/${machineId}/wait`,
        method: "GET",
        query: query,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Secrets
     * @name SecretsList
     * @summary List App secrets
     * @request GET:/apps/{app_name}/secrets
     */
    secretsList: (appName: string, params: RequestParams = {}) =>
      this.request<ListSecret[], any>({
        path: `/apps/${appName}/secrets`,
        method: "GET",
        format: "json",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Secrets
     * @name SecretDelete
     * @summary Destroy Secret
     * @request DELETE:/apps/{app_name}/secrets/{secret_label}
     */
    secretDelete: (
      appName: string,
      secretLabel: string,
      params: RequestParams = {}
    ) =>
      this.request<void, any>({
        path: `/apps/${appName}/secrets/${secretLabel}`,
        method: "DELETE",
        ...params,
      }),

    /**
     * No description
     *
     * @tags Secrets
     * @name SecretCreate
     * @summary Create Secret
     * @request POST:/apps/{app_name}/secrets/{secret_label}/type/{secret_type}
     */
    secretCreate: (
      appName: string,
      secretLabel: string,
      secretType: string,
      request: CreateSecretRequest,
      params: RequestParams = {}
    ) =>
      this.request<void, ErrorResponse>({
        path: `/apps/${appName}/secrets/${secretLabel}/type/${secretType}`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        ...params,
      }),

    /**
     * No description
     *
     * @tags Secrets
     * @name SecretGenerate
     * @summary Generate Secret
     * @request POST:/apps/{app_name}/secrets/{secret_label}/type/{secret_type}/generate
     */
    secretGenerate: (
      appName: string,
      secretLabel: string,
      secretType: string,
      params: RequestParams = {}
    ) =>
      this.request<void, ErrorResponse>({
        path: `/apps/${appName}/secrets/${secretLabel}/type/${secretType}/generate`,
        method: "POST",
        ...params,
      }),

    /**
     * @description List all volumes associated with a specific app.
     *
     * @tags Volumes
     * @name VolumesList
     * @summary List Volumes
     * @request GET:/apps/{app_name}/volumes
     */
    volumesList: (
      appName: string,
      query?: {
        /** Only return summary info about volumes (omit blocks, block size, etc) */
        summary?: boolean;
      },
      params: RequestParams = {}
    ) =>
      this.request<Volume[], any>({
        path: `/apps/${appName}/volumes`,
        method: "GET",
        query: query,
        format: "json",
        ...params,
      }),

    /**
     * @description Create a volume for a specific app using the details provided in the request body.
     *
     * @tags Volumes
     * @name VolumesCreate
     * @summary Create Volume
     * @request POST:/apps/{app_name}/volumes
     */
    volumesCreate: (
      appName: string,
      request: CreateVolumeRequest,
      params: RequestParams = {}
    ) =>
      this.request<Volume, any>({
        path: `/apps/${appName}/volumes`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Retrieve details about a specific volume by its ID within an app.
     *
     * @tags Volumes
     * @name VolumesGetById
     * @summary Get Volume
     * @request GET:/apps/{app_name}/volumes/{volume_id}
     */
    volumesGetById: (
      appName: string,
      volumeId: string,
      params: RequestParams = {}
    ) =>
      this.request<Volume, any>({
        path: `/apps/${appName}/volumes/${volumeId}`,
        method: "GET",
        format: "json",
        ...params,
      }),

    /**
     * @description Update a volume's configuration using the details provided in the request body.
     *
     * @tags Volumes
     * @name VolumesUpdate
     * @summary Update Volume
     * @request PUT:/apps/{app_name}/volumes/{volume_id}
     */
    volumesUpdate: (
      appName: string,
      volumeId: string,
      request: UpdateVolumeRequest,
      params: RequestParams = {}
    ) =>
      this.request<Volume, ErrorResponse>({
        path: `/apps/${appName}/volumes/${volumeId}`,
        method: "PUT",
        body: request,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description Delete a specific volume within an app by volume ID.
     *
     * @tags Volumes
     * @name VolumeDelete
     * @summary Destroy Volume
     * @request DELETE:/apps/{app_name}/volumes/{volume_id}
     */
    volumeDelete: (
      appName: string,
      volumeId: string,
      params: RequestParams = {}
    ) =>
      this.request<Volume, any>({
        path: `/apps/${appName}/volumes/${volumeId}`,
        method: "DELETE",
        format: "json",
        ...params,
      }),

    /**
     * @description Extend a volume's size within an app using the details provided in the request body.
     *
     * @tags Volumes
     * @name VolumesExtend
     * @summary Extend Volume
     * @request PUT:/apps/{app_name}/volumes/{volume_id}/extend
     */
    volumesExtend: (
      appName: string,
      volumeId: string,
      request: ExtendVolumeRequest,
      params: RequestParams = {}
    ) =>
      this.request<ExtendVolumeResponse, any>({
        path: `/apps/${appName}/volumes/${volumeId}/extend`,
        method: "PUT",
        body: request,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),

    /**
     * @description List all snapshots for a specific volume within an app.
     *
     * @tags Volumes
     * @name VolumesListSnapshots
     * @summary List Snapshots
     * @request GET:/apps/{app_name}/volumes/{volume_id}/snapshots
     */
    volumesListSnapshots: (
      appName: string,
      volumeId: string,
      params: RequestParams = {}
    ) =>
      this.request<VolumeSnapshot[], any>({
        path: `/apps/${appName}/volumes/${volumeId}/snapshots`,
        method: "GET",
        format: "json",
        ...params,
      }),

    /**
     * @description Create a snapshot for a specific volume within an app.
     *
     * @tags Volumes
     * @name CreateVolumeSnapshot
     * @summary Create Snapshot
     * @request POST:/apps/{app_name}/volumes/{volume_id}/snapshots
     */
    createVolumeSnapshot: (
      appName: string,
      volumeId: string,
      params: RequestParams = {}
    ) =>
      this.request<void, any>({
        path: `/apps/${appName}/volumes/${volumeId}/snapshots`,
        method: "POST",
        ...params,
      }),
  };
  tokens = {
    /**
     * @description This site hosts documentation generated from the Fly.io Machines API OpenAPI specification. Visit our complete [Machines API docs](https://fly.io/docs/machines/api/apps-resource/) for details about using the Apps resource.
     *
     * @tags Tokens
     * @name TokensRequestKms
     * @summary Request a Petsem token for accessing KMS
     * @request POST:/tokens/kms
     */
    tokensRequestKms: (params: RequestParams = {}) =>
      this.request<string, any>({
        path: `/tokens/kms`,
        method: "POST",
        format: "json",
        ...params,
      }),

    /**
     * @description Request an Open ID Connect token for your machine. Customize the audience claim with the `aud` parameter. This returns a JWT token. Learn more about [using OpenID Connect](/docs/reference/openid-connect/) on Fly.io.
     *
     * @tags Tokens
     * @name TokensRequestOidc
     * @summary Request an OIDC token
     * @request POST:/tokens/oidc
     */
    tokensRequestOidc: (
      request: CreateOIDCTokenRequest,
      params: RequestParams = {}
    ) =>
      this.request<string, ErrorResponse>({
        path: `/tokens/oidc`,
        method: "POST",
        body: request,
        type: ContentType.Json,
        format: "json",
        ...params,
      }),
  };
}
